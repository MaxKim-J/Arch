# SOLID + DRY 원칙

소프트웨어 공학의 원칙  
2020.08.03  

## SOLID 원칙

마이클 패더스, 1990년대 후반

- Single Responsibility 
- Open/Closed 
- Liskov Substitution
- Interface Segregation
- Dependency Inversion

### 단일 책임 원칙

- 함수는 무조건 하나의 변경 사유만 있어야 한다.
- 이상적인 함수는 하나의 일을 잘한다
- 만약 코드를 수정한다면 수정할 부분은 **이미 정해져 있어야** 한다.
- 모듈간의 책임 소지를 분명히 하고 관심사를 나눈다

### 개방/폐쇄 원칙

- 모든 소프트웨어 개체는 확장 가능성은 열어두되 수정 가능성은 닫아야 한다
- 어떤 경우에도 실행 코드를 변경하지 말고 **어떻게든 재사용하고 확장해라!!**
- 로버트 마틴) 완벽한 닫힘은 있을 수 없으니 모종의 전략이 필요하다. 다시 말해 설계자는 **불가피한 변경 유형을 미리 선택할 수 밖에 없다.**
- 코드는 미래로 나아간다 == 개발자는 구현체를 만들면서 어떤 방향으로든 **변경을 염두해 둘 수밖에 없고 그렇게 한다** == 닫힌 모듈은 없다
- 변경 가능성이 높은 부분과 그렇지 않은 부분을 구별한다

### 리스코프 치환 원칙

- 어떤 타입에서 파생된 타입의 객체가 있다면 이 타입을 사용하는 코드는 변경하지 말아야 한다
- **서브타입은 언제나 자신이 기반타입으로 교체할 수 있어야 한다**
- 유도된 클래스의 메소드를 퇴화시키거나 쓰지 않는 일을 피하라
- 기반 클래스의 사용자는 그 기반 클래스에서 유도된 클래스에 대해 아무것도 알 필요가 없어야 한다 == 객체는 그 단위로서 스스로 완결성을 지녀야한다.
- **한 객체를 다른 객체에서 파생하더라도 그 기본 로직이 변경되서는 안 된다**
- 기반 클래스로 하는 일과 파생된 서브 클래스로 하는 일이 다르다면 이 원칙을 어긴 셈이다.
- 어떤 함수의 인자에 따라(타입을 완벽하게 규명하기 힘들 경우) 분기 처리하는 것처럼

### 인터페이스 분리 원칙

- 인터페이스 : 클래스에서 어떤 기능을 구현하지 않고 명칭이나 파라미터, 반환 타입을 서술만한 코드 조각이다.
- **기능이 많은 인터페이스는 더 작게 응축시킨 조각으로 나누어야 한다**
- 클라이언트와 무관하게 발생한 변화로 클라이언트 자신이 영향을 받지 않으려면 범용 인터페이스보다는 클라이언트에 특화된 인터페이스를 사용해야 한다. 인터페이스를 클라이언트에 특화되도록 분리시키는 설계 원칙이다.
- 타입이 없는 버전의 자바스크립트 : 특정 타입의 인자를 바라보기보다는 이 타입에서 실제로 필요한 프로퍼티가 더러 있을 거라 기대 + 타입이 이거다! 보다는 덕타이핑처럼 어떻게 동작하는지가 중요
- 물론 지금은 타입스크립트도 나오고 해서 두리뭉실하게 의존하지 않고도 타입을 어썰션 할 수 있다.
- 덕 타이핑 : 동적 타이핑의 한 종류로 객체의 변수 및 메소드의 집합이 객체의 타입을 결정하는 것을 말함. 클래스 상속이나 인터페이스 구현으로 타입을 구분하는 대신, 덕 타이핑은 객체가 어떤 타입에 걸맞은 변수와 메소드를 지니면 객체를 해당 타입에 속하는 것으로 간주한다.

```py

# 덕타이핑 예제
class Duck:
        def quack(self): print u"꽥꽥!"
        def feathers(self): print u"오리에게 흰색, 회색 깃털이 있습니다."

class Person:
        def quack(self): print u"이 사람이 오리를 흉내내네요."
        def feathers(self): print u"사람은 바닥에서 깃털을 주워서 보여 줍니다."

def in_the_forest(duck):
        duck.quack()
        duck.feathers()

# 두 인스턴스는 같은 방식으로 동작한다고 말할 수 이따
def game():
        donald = Duck()
        john = Person()
        in_the_forest(donald)
        in_the_forest(john)
```

### 의존성 역전 원칙

- 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안되며 이 둘은 추상화에 의존해야 한다
- 모듈 자신이 자신의 의존성을 가지는게 어쩌면 일반적이지만, 그 의존성은 **의존성 주입**에 의해 외부에서 주입되기도 한다. 이때 의존성의 역전이 일어난다
- 클래스 A가 클래스 B의 서비스가 필요할 때 A는 B를 생성하지 않는다. 대신 A생성자에 건넨 파라미터 하나가 B를 서술하는 인터페이스 역할을 한다.
- 이제 A는 B에 의존하지 않고 자신의 인터페이스만 바라본다. A가 생성되면 구체화한 B를 넘겨받는다. B역시 자신의 인터페이스에만 의존한다. 서로 의존하지 않는다.

## DRY 원칙

- Don`t Repeat Yourself : 반복하지 마라
- x와 y라는 행위를 하는 모듈이 있는데, 이 모듈 밖에서 행위 x를 해야한다. 원 모듈에서는 x를 구현할 때 y로직을 들어내지 않는 한 모듈을 재사용할 수 없다면 또다시 x를 코딩해야 한다 바람직하지 않다
- x와 y를 하는 함수를 애초부터 분리해서, 모듈에 주입해 하나의 책임으로 묶어두면 문제를 해결할 수 있다
- **자바스크립트에서 더욱 중요하다.** : 코딩 실수는 늘 하기 마련인데, 자바스크립트는 잘못 코딩한 특정 클래스를 컴파일러가 미리 알려주지 않으니 자칫 그대로 운영 환경에 노출될 수 있다. 참사를 예방하려면 빨리 실수를 인지하는게 상책이므로, 의존성을 없애고 모듈을 최대한 분리하면 에러는 각개격파되기 쉬워진다.



## refernce

- [리스코프 치환 원칙](https://vandbt.tistory.com/41)
- [덕 타이핑](https://ko.wikipedia.org/wiki/%EB%8D%95_%ED%83%80%EC%9D%B4%ED%95%91)
- [자바스크립트 패턴과 테스트 - 1.1.3 소프트웨어 공학 원칙을 적용하라](http://www.yes24.com/Product/Goods/33211518)
# MVC, MVVM, FLUX

코드 단위가 아니라 프레임워크 전체 레벨에서의 디자인 패턴으로 이야기되는 MVC, MVVM, FLUX에 대해서 정리

## MVC

Model-View-Controller

![mvc](https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIfAJIv9p4lFILK8oqmjH-BwvgUa8aixv-UL5ENdvAGMSN61b2heHcTafgIaviL2b2fOAIWfm84I5qJGnaPN5qch0aGhM5Gf9R4aKGdPN8VKl1IWcm00)

- view와 model은 직접적으로 의존하지 않고, Controller을 통해 메시지를 주고 받는다. Server-side에 넘기는 User의 인터랙션이라고는 http request하나밖에 없다(화살표가 꽤 단순하다)
  - Django의 예 : 컨트롤러는 뷰함수, 모델은 데이터베이스, 뷰는 화면 그 자체나 리스폰스
  - 뷰에서 유저는 컨트롤러에 요청을 보냄(DRF라면 http request로 요청을 보내고 적당하게 뷰함수나 클래스에서 처리함)
  - 컨트롤러는 모델에 요청사항대로 데이터를 수정할 것을 지시
  - 모델은 지시받은 대로 데이터를 수정하고 컨트롤러에게 완료되었음을 알려주고
  - 컨트롤러는 수정된 데이터를 토대로 표시할 데이터 (좀더 멀리는 화면)을 정해서 출력할 것을 지시
  - 뷰는 지시받은대로 화면을 출력함
  - 사실 REST API라면 뷰가 없으니까 1:1로 대응하기 좀 어려운 지점이 있다
- 클라이언트에서의 MVC는 **다양한 유저 인터렉션이 가능하다** => 마우스, 터치, 키보드, 스크롤 등등 그래서 클라이언트 MVC는 양상이 좀 다르다
  - 컨트롤러는 model과 view를 모두 알고 있다 => UI와 Model 사이의 비즈니스 로직은 UI에도, Model에도 의존성이 생길 수 있다
  - view는 유저의 인터렉션을 알고 있다
  - view는 **어떤 model을 갱신해야하는지** 알고 있어야 한다
- 이럴 경우의 문제는
  - Model은 비즈니스 로직과 관련이 있고
  - View는 UI와 관련이 있어서 Model과 View는 변화의 이유가 다른데
  - 그런데 뷰와 모델이 서로간의 의존성이 있게 된다 
- 제왕적 MVC 모델 : 컨트롤러에게 거의 모든 책임이 있는 꼴
![mvc](https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIfAJIv9p4lFILK8oqmjH-BwvgUa8aixv-UL5ENdvAGMSN61b2hewaPdPAQafER55cMcPvJewaAqA5WfA2d0WH8NH51NLzVE3iaC1QYuZGrG1aKSR3P4M2abiIHH2TbcgCMePd4vfEQb0Fq20000)
  - 컨트롤러는 자신이 소비할 Model과 View를 생성하거나 섭외해야할 책임을 갖는다
  - Model은 순수한 데이터를 표현하며 자신이 소유하고 있는 데이터의 변경이 일어날때마다 또 컨트롤러에게 알려야할 책임을 갖는다
  - View는 컨트롤러가 전달해주는 모델을 기반으로 화면을 구성하고 유저 인터렉션을 받아들인다
  - 컨트롤러가 뷰와 모델의 변화를 모두 따라가야할 책임이 있고, 그럴수록 컨트롤러의 변화가 매우 많아지게 된다 => 유지보수가 매우 어려워진다
  - View와 Model의 변화가 사실상 양방향이 되고 컨트롤러는 매우 복잡해진다. 거의 서로 강하게 바인딩이 되는 느낌
- 이러니까 MVC를 잘 안 쓰게 된다

## MVVM

![mvvm](https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIfAJIv9p4lFILK8oqmjH-8wPUQbf1OX2VZcfwJcS2Mcf-QLWDL2-5mWfe9kT4PcIafgNYn4bOALWf825g04KMrZewiBCnz2AUZQsI4C1MdNqifFAaujAaijqj9Iue88W_KXL455TL7rSZcavgK0VGO0)

- ViewModel : View를 대신하는 순수한 데이터 구조체로, 순수한 인메모리 객체이다
- Binder : ViewModel의 **변화를 감지**하여 View에 반영한다
  - 양방향 바인딩의 경우 Binder가 View에도 Observing을 하는 상태로, Binder가 View와 ViewModel 모두 감지하여 모두 반영한다(Vue와 Angular)
  - Binder가 없으면 MVVM이 성립하지 않으며, 바인더가 있기 때문에 **ViewModel을 View의 존재를 모르는 상태로 유지할 수 있다** => 이게 약간 MVC와의 명시적인 차이같은데 Model이 View를 알게 되는 상태에서 벗어날 수 있다

## Flux

![flux](https://taeny.dev/static/8ef687083384d183ff57c029daa5a6c4/9f82e/flux.png)

- MVC 방식에서는 모델의 변화에 따라 뷰가 변하는 방식이기 때문에 시스템이 복잡해질수록 예측 불가능한 상황들이 발생할 수 있고, 데이터들이 꼬여버릴 수 있다는 단점을 가지고 있다
![mvc](https://taeny.dev/static/7ee5bf84ed49bf3e248afaac077b9196/c483d/mvcbinding.png)
- Flux 패턴은 MVC의 이런 양방향 데이터 바인딩의 단점을 해결하고자 하는 단방향 바인딩 방식의 디자인 패턴이다. 오직 액션의 호출로만 store(model)이 바뀐다
- 이거 자체는 프레임워크를 관통하는 디자인패턴의 개념이라고 말하기는 힘들고(리액트에서 그것은 MVVM에 가깝다) Redux, 혹은 useReducer을 사용했을때 국지적으로 View를 변경하는데 쓰이게 되는 또다른 방식에 적용되는 디자인 패턴에 가깝다.
  - dispatch는 모델이나 뷰모델을 변화시킨다
  - store는 모델과 뷰모델을 좀 크게 둘러싸는 개념이다 

## React에서의 MVVM 취지에 맞게 구현하기

오늘(2021.08.23) [React와 MVVM에 관련한 포스팅](https://www.bsidesoft.com/8280)을 읽다가 React Hook을 이용해 MVVM을 좀 더 취지에 맞게 구현할 수 있는 방법은 없을까?? 고민이 많이 되었다. 

이미 MVVM에서의 큰 흐름을 따르고 있는 React이기는 한데, 거시적인 흐름에서만 그렇고 **뷰모델은 특정 컴포넌트에 의존할 수 있는 가능성이 있고, 여러개의 뷰모델이 컴포넌트 안에서 혼재할 수 있는 가능성도 존재한다.**

일반적으로 생각해봤을 때 useEffect나 useState, 그리고 여러 함수들을 포함하고 있는 컴포넌트를 생각해보면 특별한 신경을 쓰지 않을때 앱의 비즈니스 로직이라고 부를 수 있는 것들이 순서와 상관없이, 관심사와 상관없이 그냥 혼재하기 쉽게 개발되기 쉬운 환경이라고 할 수 있다.

모델의 데이터가 어플리케이션단에서 어떻게 쓰일 수 있는지에 대해 충분히 설명하고 데이터를 최대한 팀의 개발자들이 규칙에 부합하게 예측 가능한 방향으로 쓸 수 있게 하려면 React 컴포넌트에서 뷰모델의 취지를 살리는 자료구조가 필요하다고 생각했다

### Custom Hook으로 뷰모델 분리하기

도메인 오리엔티드한 데이터를 포함하는 컴포넌트 내 로직들을 커스텀 훅으로 분리한다. 모델의 데이터의 변화에 따라 전처리된 데이터를 만드는 useMemo로 만든 프로퍼티들, 모델의 데이터를 변경할 수 있는 요청이 구현된 함수 등을 커스텀 훅으로 모두 분리하여 컴포넌트에서 호출해서 사용한다.

특정 컴포넌트에 의존하지 않게끔 만들어야 한다

구현이 복잡한 헬퍼 로직들은 헬퍼 함수들을 따로 구현할 수 있는 곳에서 구현해도 좋을 것 같다  

컴포넌트간 재사용을 할때 불필요한 로직까지 붙을 수 있는 지점이 생길 것 같다. 이걸 최대한 피하려면 컴포넌트에 해당되는 로직만 따로 훅으로 분리하거나 해야할거 같은데 그러면 이걸 뷰모델이라고 부를 수 있나 싶다 그냥 각 컴포넌트에 의존하는 로직들을 따로 뗀 정도지...

### Redux와 Saga에 VM의 역할을 위임하기

Saga에서는 Model을 바꾸는 로직을, 전처리된 데이터는 toolkit의 reselect를 이용하여 제공한다. 커스텀 훅의 구현부에서 작성이 가능한 로직을 Redux에 위임하여 코어를 더 단단히 만드는 방식이다. 

컴포넌트에서는 거의 action을 dispatch하거나 reselect한 selector을 가져오는 방식으로 구현이 된다

관련 로직들을 Custom Hook으로 한번 싸서 제공하는 것 까지 하면 더 괜찮은 추상화를 만들어낼 수 있을 것으로 보이지만 이 경우에는 크게 필요없을수도 있다

단점으로는 다양한 Saga를 만들어낼 수도 있고 해서 안그래도 많은 Saga의 타이핑을 더 부추기는게 아닌가 생각이 든다.. 

그리고 모든 프로젝트에 리덕스와 사가를 사용하는 것이 아니기 때문에.. React Query나 SWR처럼 중앙 집중화된 방식으로 비동기 로직을 관리하는 것이 아니라면 이런 느낌으로는 뷰모델 구현을 할 수 없다.

### 뷰모델 클래스로 횡단 관심사 분리하기

아까 링크했던 포스트에서 보여줬던 방식인데, 완전 쌉고수가 아니면 따라하기 힘든 방식인거 같기도 하고 뭐 그렇다

뷰모델 클래스를 만들고, 컴포넌트에서 주입이 가능한 setState 함수를 통해 클래스 인스턴스의 멤버변수를 바꾸면서 재랜더링을 유도하는 방식이다

클래스를 state에 넣어 사용하는 방식이라서 먼가 생소하다. 하지만 딱 데이터와, 그 데이터에 의존하는 로직들을 클래스 하나에 넣어 엄격하게 사용할 수 있다

useEffect나 useSelector을 같이 사용한다면 궁합이 별로일 수도 있을 것 같다는 생각이 든다 내가 쌉고수가 아니라서 대안을 못찾는 것일수도 있다..

전반적으로 이렇게까지 해야하나...? 하는 생각이 든다 React에서 제공하는 좋은 커스텀 훅들과 상태관리 도구들을 제대로 사용하지 못하게 하는 느낌이 좀 들어서...  

### 현재로서 생각할 수 있는 제일 좋은 방식 

- 뷰모델은 일단 클래스로 분리하여 특정 데이터에 필요한 로직들을 차곡차곡 쌓아둔다
- 컴포넌트 단에서는 **모델 데이터를 수정하는 세부적인 구현을 최에대한 하지 않는다** 그냥 useMemo나 useEffect, useState 정도만 사용하고 뷰모델에 관련된 로직은 뷰모델 클래스의 메소드로 구현한다
- 그리고 뷰모델 클래스를 테스팅해서 **왠만한 구현부는 뷰모델단에서 모두 테스트할 수 있도록 만든다**
- 비동기 로직은 커스텀훅으로 감싸서 제공하되 재사용에 용이할 수 있도록 useMemo나 useEffect같은거 쓰지 않고 selector와 래퍼 함수만을 제공한다. 여기서도 뷰모델 클래스를 사용할 수 있다